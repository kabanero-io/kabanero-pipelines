#Kabanero! on activate substitute Digest for text '@Digest@'
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: build-push-task-@Digest@
spec:
  inputs:
    resources:
    - name: git-source
      type: git
  outputs:
    resources:
    - name: docker-image
      type: image
    - name: git-source
      type: git
  steps:
  - name: enforce-stack-policy-pre-build
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        /workspace/$gitsource/enforce_stack_policy.sh
        
    env:
    - name: gitsource
      value: git-source
    - name: DEFAULT_STACK_IMAGE_REGISTRY_URL
      valueFrom:
        configMapKeyRef:
         name: stack-image-registry-map
         key: default-stack-image-registry-url
         optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: username
          optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: password
          optional: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    - name: config-volume
      mountPath: /config
    - name: secret-volume
      mountPath: /etc/secret-volume        
  - name: build
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        #executing the insecure_registry_setup.sh script if exists, to add internal registry to insecure registry list
        if [ -f "/workspace/$gitsource/insecure_registry_setup.sh" ]; then
           echo "Running the script /workspace/$gitsource/insecure_registry_setup.sh ...."
           /workspace/$gitsource/insecure_registry_setup.sh
           echo "printing the content /etc/containers/registries.conf"
           cat /etc/containers/registries.conf
        fi

        #executing the ca_certs_setup.sh script if exists, to add additional trusted ca certs to /etc/docker/certs.d/<hosname>/ca.crt
        if [ -f "/workspace/$gitsource/ca_certs_setup.sh" ]; then
           echo "Running the script /workspace/$gitsource/ca_certs_setup.sh ...."
           /workspace/$gitsource/ca_certs_setup.sh
        fi
        
        echo "Configmap value for DEFAULT_STACK_IMAGE_REGISTRY_URL=$DEFAULT_STACK_IMAGE_REGISTRY_URL"

        if [ -z "$DEFAULT_STACK_IMAGE_REGISTRY_URL" ]
        then
            echo "DEFAULT_STACK_IMAGE_REGISTRY_URL not configured in a config map.  Look for the stack registry info in the .appsody-cfg file."
            APPSODY_CONFIG=".appsody-config.yaml"
            
            # Default the stack registry to docker.io
            STACK_IMAGE_REGISTRY_URL="docker.io"

            cd /workspace/$gitsource
            
            if [ ! -f "$APPSODY_CONFIG" ]; then
                echo "$APPSODY_CONFIG is not found in the root of the source directory."
            else
                # Find the value for "stack:" from the appsody config file and assign it to the variable 'stack'
                declare $( awk '{if ($1 ~ "stack:"){printf "STACK="$2}}'  $APPSODY_CONFIG )
                if [ -z "$STACK" ]; then
                  echo "$APPSODY_CONFIG does not contain a stack definition."
                fi
            fi

            # The stack registry may or may not be in the appsody-cfg.yaml file
            # If it's there the format should be like registry/project/name:version
            # It could also just be project/name:version.
            # Try to determine if the registry is there and if it is, parse it out
            NUM_SLASHES=$(awk -F"/" '{print NF-1}' <<< "${STACK}")
            if [ "$NUM_SLASHES" = 1 ]; then
                echo "No stack registry specified in $APPSODY_CONFIG. Using docker.io as the stack registry."
            elif [ "$NUM_SLASHES" = 2 ]; then
                STACK_IMAGE_REGISTRY_URL="$(echo $STACK | cut -d'/' -f1)"
                echo "Stack registry specified in $APPSODY_CONFIG as $STACK_IMAGE_REGISTRY_URL.  Using this as the stack registry."
            else
                echo "Unexpeted format for stack in APPSODY_CONFIG. Using docker.io as the stack registry"
            fi
        else
            echo "Using stack image registry url setup by user in configmap as $DEFAULT_STACK_IMAGE_REGISTRY_URL"
            STACK_IMAGE_REGISTRY_URL=$DEFAULT_STACK_IMAGE_REGISTRY_URL
        fi
        
        echo  "Looking for stack registry at $STACK_IMAGE_REGISTRY_URL"

        if [[ ( -z "$DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME" ) || ( -z "$DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD" ) ]]
        then
            echo "DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME or DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD is empty.  Assumption is authentication to the registry is not required."
        else
            echo "Secrets are provided to login to stack registry"
            echo "buildah login -u $DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME -p $DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD \${HOST}" >> cert-creation.sh
        fi

        cd /workspace/$gitsource
 
        OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE=$( /workspace/$gitsource/imageurl_imagename_lowercase.sh )
        retVal=$?
        if [ $retVal -ne 0 ]
        then
           echo "The script failed(/workspace/$gitsource/imageurl_imagename_lowercase.sh) Reason: $OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE" >&2
           exit $retVal
        fi

        echo "OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE=$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE"

        appsody build -t "$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE" --buildah --buildah-options "--format=docker" --stack-registry "$STACK_IMAGE_REGISTRY_URL"
        echo "Copying the generated app-deploy.yaml file from input to the output to pass the file to the next task when this task is used in deploy pipeline"
        cp app-deploy.yaml $(outputs.resources.git-source.path)
    env:
    - name: gitsource
      value: git-source
    - name: DEFAULT_STACK_IMAGE_REGISTRY_URL
      valueFrom:
        configMapKeyRef:
         name: stack-image-registry-map
         key: default-stack-image-registry-url
         optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: username
          optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: password
          optional: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    - name: config-volume
      mountPath: /config
    - name: secret-volume
      mountPath: /etc/secret-volume
  - name: enforce-stack-policy-post-build
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        /workspace/$gitsource/enforce_stack_policy.sh
        
    env:
    - name: gitsource
      value: git-source
    - name: DEFAULT_STACK_IMAGE_REGISTRY_URL
      valueFrom:
        configMapKeyRef:
         name: stack-image-registry-map
         key: default-stack-image-registry-url
         optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_USERNAME
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: username
          optional: true
    - name: DEFAULT_STACK_IMAGE_REGISTRY_SECRET_PASSWORD
      valueFrom:
        secretKeyRef:
          name: default-stack-image-registry-secret
          key: password
          optional: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    - name: config-volume
      mountPath: /config
    - name: secret-volume
      mountPath: /etc/secret-volume       
  - name: push
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |

        OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE=$( /workspace/$gitsource/imageurl_imagename_lowercase.sh)
        retVal=$?
        if [ $retVal -ne 0 ]
        then
           echo "The script failed(/workspace/$gitsource/imageurl_imagename_lowercase.sh) Reason: $OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE" >&2
           exit $retVal
        fi
        echo "OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE=$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE"

        #executing the insecure_registry_setup.sh script if exists, to add internal registry to insecure registry list
        if [ -f "/workspace/$gitsource/insecure_registry_setup.sh" ]; then
           echo "Running the script /workspace/$gitsource/insecure_registry_setup.sh ...."
           /workspace/$gitsource/insecure_registry_setup.sh
        fi

        #executing the ca_certs_setup.sh script if exists, to add additional trusted ca certs to /etc/docker/certs.d/<hosname>/ca.crt
        if [ -f "/workspace/$gitsource/ca_certs_setup.sh" ]; then
           echo "Running the script /workspace/$gitsource/ca_certs_setup.sh ...."
           /workspace/$gitsource/ca_certs_setup.sh
        fi

        REPO=`cat /etc/imagesigning.conf/registry`
        if [[ -z $REPO ]]
        then
           echo "Signature will not be generated."
           buildah push --tls-verify=true "$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE" "docker://$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE"
        else
           echo "Sigstore will be generated."
           if [[ $OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE != $REPO/* ]]; then
              echo "The specified signed image repository does not match the name of the repository in sign-secret-key secret resource. The repository name should start with $REPO, Specified signed image name is $OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE"
              exit 1
           fi

           SIGSTORE_URL=`cat /etc/imagesigning.conf/sigstore`
           gpg --import /etc/imagesigning.conf/secret.asc
           SIGNBY=`gpg --list-keys|sed -n -e "/.*<.*>.*/p"|sed -e "s/^.*<\(.*\)>.*$/\1/"`
           skopeo --debug copy --dest-tls-verify=true --remove-signatures --sign-by $SIGNBY "containers-storage:$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE" "docker://$OUTPUTS_RESOURCE_DOCKER_IMAGE_URL_LOWERCASE"

           if [[ -z $SIGSTORE_URL ]]; then
              echo "Signature is stored in the image registry"
           else
              LOCAL_SIGSTORE="/workspace/signtask/sigstore"
              SPLITTED=(${REPO//// })
              REPOSITE=${SPLITTED[0]}
              NAMESPACE=`ls $LOCAL_SIGSTORE`
              NAMESPACE=$NAMESPACE/`ls $LOCAL_SIGSTORE/$$NAMESPACE`
              TOKEN=`cat /var/run/secrets/kubernetes.io/serviceaccount/token`
              echo $REPOSITE
              echo $NAMESPACE
              echo $SIGSTORE_URL/staging/store.php
              for d in $LOCAL_SIGSTORE/**/*; do
                 for f in $d/*;do
                    echo $f
                    curl -H "Authorization: Bearer $TOKEN" -F "signature=@$f" -F "namespace=$NAMESPACE" -F "registry=$REPOSITE" -F "form_submitted=1" -k -s $SIGSTORE_URL/staging/store.php >> /workspace/result.txt
                 done
              done
              cat /workspace/result.txt
              if cat /workspace/result.txt | grep "^Result:Failure:"
              then
                 false
              else
                 cat /workspace/result.txt | grep "^Result:Success:"
              fi
           fi
        fi
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    - mountPath: /etc/imagesigning.conf
      name: image-signing-config
    - mountPath: /etc/containers/registries.d
      name: registries-d
  volumes:
  - name: varlibcontainers
    emptyDir: {}
  - name: config-volume
    configMap:
      name: stack-image-registry-map
      optional: true
  - name: registries-d
    configMap:
      name: registries-d
      optional: true
  - name: secret-volume
    secret:
      secretName: default-stack-image-registry-secret
      optional: true
  - name: image-signing-config
    secret:
      secretName: image-signing-config
      optional: true

