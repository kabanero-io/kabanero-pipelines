#Kabanero! on activate substitute StackId for text 'StackId'
apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: StackId-utilities-task
spec:
  inputs:
    resources:
    - name: docker-image
      type: image
    - name: git-source
      type: git
    params:
    - name: docker-imagename
      type: string
      default: ""
    - name: docker-imagetag
      type: string
      default: ""
  outputs:
    resources:
    - name: git-source
      type: git
  steps:
  - name: registry-connection-setup
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        # This step is fetching the values of 'registries.insecure' from the 'image.config.openshift.io/cluster' resource
        # and generating a script insecure_registry_setup.sh that will be used by the tasks for setting the
        # 'registries.insecure' in /etc/containers/registries.conf file of the contianer.  
          
        echo "preparing script for setting internal registry as insecure registry in /etc/containers/registries.conf file "

        internal_registry_internal_url=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.status.internalRegistryHostname}")
        insecure_registries_string=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.spec.registrySources.insecureRegistries[*]}")
        if [[ ! -z "$insecure_registries_string" ]]; then
           echo "The insecure image registry list found"
 
           IFS=' ' # space is set as delimiter
           read -ra ADDR <<< ''"$insecure_registries_string"'' # str is read into an array as tokens separated by IFS
           for i in ''"${ADDR[@]}"''; do # access each element of array
             if [[ ! -z ''"$INSECURE_REGISTRTY"'' ]]; then
               INSECURE_REGISTRTY=''"$INSECURE_REGISTRTY"', '"'"''"$i"''"'"''      
             else
               INSECURE_REGISTRTY=''"'"''"$i"''"'"''
             fi
           done
           
           if [[ ! -z "internal_registry_internal_url" ]]; then
             INSECURE_REGISTRTY=''"$INSECURE_REGISTRTY"', '"'"''"$internal_registry_internal_url"''"'"''
           fi

        else
           if [[ ! -z "internal_registry_internal_url" ]]; then
             INSECURE_REGISTRTY=''"'"''"$internal_registry_internal_url"''"'"''
           fi 
        fi
        
    
        cat <<- EOF > insecure_registry_setup.sh
         
           #example original string :
           #[registries.insecure]
           #registries = []
           ORIGINAL_STRING='\[registries\.insecure\]\nregistries = \[\]'

           #example replace string
           #[registries.insecure]
           #registries = ['pqr.com', 'abc.com']
           REPLACE_STRING='\[registries\.insecure\]\nregistries = \['"$INSECURE_REGISTRTY"'\]'

           sed -i -e ':a;N;\$!ba;s|'"\$ORIGINAL_STRING"'|'"\$REPLACE_STRING"'|' /etc/containers/registries.conf

        EOF
           chmod +x insecure_registry_setup.sh
           echo "Printing the content of script insecure_registry_setup.sh"
           cat insecure_registry_setup.sh

           echo "copying the script insecure_registry_setup.sh to output path"
           cp insecure_registry_setup.sh $(outputs.resources.git-source.path)
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  - name: trusted-ca-certs-setup
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        # This step is generating a script 'ca_certs_setup.sh' that will be used in later tasks to fetch the trusted cs certificates configured 
        # in a configmap and set in the 'image.config.openshift.io/cluster' resource by the user, and we will copy the certificate values as '/etc/docker/certs.d/<hostname>/ca.crt' for each certificate on the container.
        
        echo "script for setting additionalTrustedCA as 'ca.crt' from the configmap configured in 'image.config.openshift.io/cluster' resource"

        cat <<- "EOF" > ca_certs_setup.sh

        #First we generate internal registry internal route url ca.crt certficate allowing internal registry
        #internal route to access the registry to avoid X509 certificate error.
        internal_registry_internal_url=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.status.internalRegistryHostname}")
        if [[ ! -z "internal_registry_internal_url"  ]];then
               echo "Creating the certificate for internal_registry_internal_url=$internal_registry_internal_url"
               #Creating a cert for the internal image registry url

               HOST=$internal_registry_internal_url
               sudo mkdir -p /etc/docker/certs.d/${HOST}
               openssl s_client -connect ${HOST} -servername ${HOST} 2>/dev/null </dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sudo tee -a /etc/docker/certs.d/${HOST}/ca.crt
        fi

        #Secondly we find if cluster resource image.config.openshift.io/cluster has any additional_trusted_ca setup by user
        #If yes we pull the certificate values from the configmap setup there and create ca.crt files for each hostname with 
        #the certificate value given by the user
        
        additonal_trusted_CA=$(kubectl get image.config.openshift.io/cluster -o yaml --output="jsonpath={.spec.additionalTrustedCA.name}")
        if [[ ! -z "$additonal_trusted_CA" ]]; then
           echo "additonal_trusted_CA=$additonal_trusted_CA found in the image.config.openshift.io/cluster resource, setting up the certificates in /etc/docker/certs.d/ location"        
           config_map_key_count=$(kubectl get configmap $additonal_trusted_CA -n openshift-config -o json | jq '.data' | jq 'keys | length')

           for ((i=0;i<config_map_key_count;i++));do
              key=$(kubectl get configmap $additonal_trusted_CA -n openshift-config -o json | jq '.data' | jq 'keys['"$i"']')

              #sed command to remove double quotes from beginning and the end of the above key(example key="abc.pqr.com") variable value
              key=$(sed -e 's/^"//' -e 's/"$//' <<<$key)

              #sed command to replace '.' with '\.' to escape it while using ahead to fetch that key's value from the map
              key_hostname_with_escaped_dot=$(sed -e 's/\./\\./g' <<< "$key")

              cert_value=$(kubectl get configmap $additonal_trusted_CA -n openshift-config --output="jsonpath={.data.$key_hostname_with_escaped_dot}")
              mkdir -p /etc/docker/certs.d/$key
              echo "$cert_value" | sudo tee -a /etc/docker/certs.d/$key/ca.crt
           done

        fi

        EOF
        
        chmod +x ca_certs_setup.sh
        echo "The following script has been copied to the workspace: ca_certs_setup.sh"
        cat ca_certs_setup.sh

        echo "copying the script ca_certs_setup.sh to output path"
        cp ca_certs_setup.sh $(outputs.resources.git-source.path)

    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  - name: imagename-lowercase
    securityContext:
      privileged: true
    image: kabanero/kabanero-utils:0.8.0
    command: ["/bin/bash"]
    args:
      - -c
      - |
        #This step generates a script with the logic to change docker-image resource url with image_name as lowercase.
        # usage example 1 in usecases where input param 'docker-imagename=appsodyMPversion' and 'docker-imagetag=abcDEF' is present and 'docker-iamge' url= image-registry.openshift-image-registry.svc:5000/kabanero
        #  Then output should be url with docker-imagename 'appsodyMPversion' as lowercase, OutputURL = 'image-registry.openshift-image-registry.svc:5000/kabanero/appsodympversion:abcDEF'
        # usage example 2 in jenkins case where input param 'docker-imagename' and 'docker-imagetag' are empty ,'docker-image' url=docker.io/abcd, and if app-deploy file has 'name=java-MP-project' 
        #  Then first the url is constructed from 'app-deploy.yaml' file from the github application project. Secondly the imagename in the url is converted to lowercase.
        #  Output should be a constructed url and lowercase 'docker-imagename=java-mp-project', OutputURL = 'docker.io/abcd/java-mp-project' 

        cat <<- "EOF" > imageurl_imagename_lowercase.sh
        #Script Usage ./imageurl_imagename_lowercase.sh

        docker_registry_url=$(inputs.resources.docker-image.url)
        docker_imagename=$(inputs.params.docker-imagename)
        docker_imagetag=$(inputs.params.docker-imagetag)
        app_deploy_filename="app-deploy.yaml"

        if [[ -z "$docker_registry_url" ]]; then
           echo "Error : The input parameter docker-image resource url to the script is empty, please provide it and try again(Possible value example: docker.io/<docker-userid>, image-registry.openshift-image-registry.svc:5000/kabanero)"
           exit 1
        else
           if [[ -z "$docker_imagename"  ]]; then
              if [[ -f /workspace/$gitsource/$app_deploy_filename ]];then
                 cd /workspace/$gitsource
                 APPNAME=$(awk '/^  name:/ {print $2; exit}' $app_deploy_filename)

                 docker_imagename_lowercase=$(echo $APPNAME |  tr '[:upper:]' '[:lower:]')
              else
                 echo "Error : docker_imagename is empty and the $app_deploy_filename is not present in the github appsody project.
                 Either provide the value for the variable or make the $app_deploy_filename file available in the github appsody project
                 Case 1: If you are running a pipeline where you do not want the docker imagename to be coming from 'app-deploy.yaml' ,
                         you would need to provide the imagename from the Trigger file.
                         (Hint: Check the pipeline trigger file passing the input parameter 'docker_imagename' to the pipelines)
                 Case 2: If your requirement is to pull the imagename from the  'app-deploy.yaml' file variable 'name' , 
                         then you need to make sure that you have the file available in the appsody project in github whose url you have provided as git-source to the pipeline"
                 exit 1                 
              fi
           else
              docker_imagename_lowercase=$(echo $docker_imagename |  tr '[:upper:]' '[:lower:]')
           fi
        fi

          #If it reaches here it means it has set the variable docker_imagename_lowercase correctly.
        if [[ ! -z "$docker_imagetag" ]]; then
            DOCKER_IMAGE_URL=$docker_registry_url/$docker_imagename_lowercase:$docker_imagetag
        else
            DOCKER_IMAGE_URL=$docker_registry_url/$docker_imagename_lowercase
        fi
        echo "$DOCKER_IMAGE_URL"
          
        EOF
        chmod 755 imageurl_imagename_lowercase.sh

        echo "The following script has been copied to the workspace:imageurl_imagename_lowercase.sh "
        cat imageurl_imagename_lowercase.sh
        
        #Copy of all the content of git-source from input resources to output resources, so it could be passed to next task.
        cp -r $(inputs.resources.git-source.path)/. $(outputs.resources.git-source.path)
        #Copy the script 'imageurl_imagename_lowercase.sh' generated here to output git-source resource.
        cp imageurl_imagename_lowercase.sh $(outputs.resources.git-source.path)
    env:
    - name: gitsource
      value: git-source
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
  volumes:
  - name: varlibcontainers
    emptyDir: {}